{"version":3,"file":"314.56753c6b.iframe.bundle.js","mappings":";;;;;AAWA;;;;ACNA;;AAEA;;;AAIA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACOA;;;ACNA;AACA;AACA;AACA;;;AAGA;;;AAIA;AACA;AACA;AACA;AACA;;;;;AA4EA;;;AAlCA;AACA;;AAEA;AACA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;;;AAGA;;AAEA;;;AAeA;;;;;;;;;;;;;;;;AChGA;;;ACPA;;;ACgBA;AACA;AACA;AACA;AACA;;;;AAIA;AFvBA;AACA;;;AEuBA;;;;;AAKA;;;AAGA;;;AAGA;;AAGA;AAEA;;;AAGA;;AAGA;AFpCA;;;;;;AEsCA;;AAEA;AFjCA;;;;;;AEmCA;;AAGA;AACA;;;AAIA;;;AAGA;;AAGA;AACA;;AAIA;;;AAMA;;;AAGA;;AAIA;;AAWA;AAEA;;AAIA;AAIA;AACA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3GA;;;AAgDA;;;AAGA;AACA;AACA;;AAgBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACqCA;;;;;AAcA;;AL7BA;;;;;;;;;;;AKgCA;;AAEA;;;AD9BA;;AE7BA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0IA;AA4CA;;;;AAIA;AACA;;AAEA;;;AAGA;AAUA;AACA;;;AAiBA;AHzJA;AACA;;AGyJA;AAMA;;;;;;AAMA;;AAMA;;AAOA;;AAOA;AAKA;;;;;;AAaA;AAIA;;AAKA;;ACzLA;;AAmBA;;;ACOA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkDA;;AAIA;AACA;;;;AAIA;AAGA","sources":["webpack://@securityscorecard/design-system/./node_modules/@storybook/addon-docs/blocks.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/ErrorMessage.js","webpack://@securityscorecard/design-system/./node_modules/lit-html/directives/style-map.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/DistanceGuide.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/Icons.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/utils.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/InspectorView/InspectorView.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/Node.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/utils.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/Footer/Footer.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/ViewerMixin.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFrameViewer.js","webpack://@securityscorecard/design-system/./node_modules/@figspec/components/esm/es2015/FigspecViewer/FigspecFileViewer.js"],"sourcesContent":["import deprecate from 'util-deprecate';\nimport dedent from 'ts-dedent';\n\nconst warnBlocksImport = deprecate(\n  () => {},\n  dedent`\n    Importing from '@storybook/addon-docs/blocks' is deprecated, import directly from '@storybook/addon-docs' instead:\n    \n    https://github.com/storybookjs/storybook/blob/next/MIGRATION.md#deprecated-scoped-blocks-imports\n`\n);\nwarnBlocksImport();\n\nexport * from './dist/esm/blocks';\n","import { css, html } from \"lit-element\";\nexport const ErrorMessage = ({ title, children }) => html `\n  <div class=\"error-background\">\n    <div class=\"error-container\">\n      <span class=\"error-title\"\n        ><span class=\"error-badge\">Error</span>${title}</span\n      >\n      <span class=\"error-description\">${children}</span>\n    </div>\n  </div>\n`;\nexport const styles = css `\n  .error-background {\n    position: absolute;\n    top: 0;\n    left: 0;\n    width: 100%;\n    height: 100%;\n\n    background: var(--error-bg);\n    color: var(--error-fg);\n  }\n\n  .error-container {\n    max-width: 800px;\n    margin: auto;\n    padding: 1em;\n  }\n\n  .error-badge {\n    display: inline-block;\n    font-size: 0.8em;\n    padding: 0.2em 0.5em;\n    margin-inline-end: 0.5em;\n\n    background: var(--error-color);\n    border-radius: 2px;\n    color: var(--error-bg);\n    text-transform: uppercase;\n  }\n\n  .error-title {\n    display: block;\n    font-size: 1.2em;\n\n    font-weight: bold;\n    text-transform: capitalize;\n  }\n\n  .error-description {\n    display: block;\n    margin-block-start: 1em;\n  }\n`;\n","/**\n * @license\n * Copyright (c) 2018 The Polymer Project Authors. All rights reserved.\n * This code may only be used under the BSD style license found at\n * http://polymer.github.io/LICENSE.txt\n * The complete set of authors may be found at\n * http://polymer.github.io/AUTHORS.txt\n * The complete set of contributors may be found at\n * http://polymer.github.io/CONTRIBUTORS.txt\n * Code distributed by Google as part of the polymer project is also\n * subject to an additional IP rights grant found at\n * http://polymer.github.io/PATENTS.txt\n */\nimport { AttributePart, directive, PropertyPart } from '../lit-html.js';\n/**\n * Stores the StyleInfo object applied to a given AttributePart.\n * Used to unset existing values when a new StyleInfo object is applied.\n */\nconst previousStylePropertyCache = new WeakMap();\n/**\n * A directive that applies CSS properties to an element.\n *\n * `styleMap` can only be used in the `style` attribute and must be the only\n * expression in the attribute. It takes the property names in the `styleInfo`\n * object and adds the property values as CSS properties. Property names with\n * dashes (`-`) are assumed to be valid CSS property names and set on the\n * element's style object using `setProperty()`. Names without dashes are\n * assumed to be camelCased JavaScript property names and set on the element's\n * style object using property assignment, allowing the style object to\n * translate JavaScript-style names to CSS property names.\n *\n * For example `styleMap({backgroundColor: 'red', 'border-top': '5px', '--size':\n * '0'})` sets the `background-color`, `border-top` and `--size` properties.\n *\n * @param styleInfo {StyleInfo}\n */\nexport const styleMap = directive((styleInfo) => (part) => {\n    if (!(part instanceof AttributePart) || (part instanceof PropertyPart) ||\n        part.committer.name !== 'style' || part.committer.parts.length > 1) {\n        throw new Error('The `styleMap` directive must be used in the style attribute ' +\n            'and must be the only part in the attribute.');\n    }\n    const { committer } = part;\n    const { style } = committer.element;\n    let previousStyleProperties = previousStylePropertyCache.get(part);\n    if (previousStyleProperties === undefined) {\n        // Write static styles once\n        style.cssText = committer.strings.join(' ');\n        previousStylePropertyCache.set(part, previousStyleProperties = new Set());\n    }\n    // Remove old properties that no longer exist in styleInfo\n    // We use forEach() instead of for-of so that re don't require down-level\n    // iteration.\n    previousStyleProperties.forEach((name) => {\n        if (!(name in styleInfo)) {\n            previousStyleProperties.delete(name);\n            if (name.indexOf('-') === -1) {\n                // eslint-disable-next-line @typescript-eslint/no-explicit-any\n                style[name] = null;\n            }\n            else {\n                style.removeProperty(name);\n            }\n        }\n    });\n    // Add or update properties\n    for (const name in styleInfo) {\n        previousStyleProperties.add(name);\n        if (name.indexOf('-') === -1) {\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            style[name] = styleInfo[name];\n        }\n        else {\n            style.setProperty(name, styleInfo[name]);\n        }\n    }\n});\n//# sourceMappingURL=style-map.js.map","import { css, svg } from \"lit-element\";\nimport { styleMap } from \"lit-html/directives/style-map\";\nimport { getDistanceGuides, round } from \"./utils\";\nconst Line = ({ guide, reverseScale }) => {\n    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);\n    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);\n    if (xLength === 0 && yLength === 0) {\n        return null;\n    }\n    return svg `\n    <line\n      class=\"distance-line\"\n      x1=${guide.points[0].x}\n      y1=${guide.points[0].y}\n      x2=${guide.points[1].x}\n      y2=${guide.points[1].y}\n    />\n\n    ${guide.bisector &&\n        svg `\n        <line\n          class=\"distance-line\"\n          x1=${guide.bisector[0].x}\n          y1=${guide.bisector[0].y}\n          x2=${guide.bisector[1].x}\n          y2=${guide.bisector[1].y}\n          style=${styleMap({\n            strokeDasharray: `${4 * reverseScale}`,\n        })}\n          shape-rendering=\"geometricPrecision\"\n          fill=\"none\"\n        />\n      `}\n  `;\n};\nconst Tooltip = ({ guide, reverseScale, fontSize }) => {\n    const xLength = Math.abs(guide.points[0].x - guide.points[1].x);\n    const yLength = Math.abs(guide.points[0].y - guide.points[1].y);\n    if (xLength === 0 && yLength === 0) {\n        return null;\n    }\n    const text = round(Math.max(xLength, yLength)).toString(10);\n    // Decreases font width because every text is a number (narrow).\n    // We can measure the correct width with getComputedTextLength method on\n    // <text> element, but it needs access to DOM or creating an element each\n    // render cycle, both have performance costs.\n    const width = text.length * fontSize * 0.5;\n    const startMargin = fontSize * 0.25;\n    const vPadding = fontSize * 0.25;\n    const hPadding = fontSize * 0.5;\n    const x = xLength > yLength\n        ? (guide.points[0].x + guide.points[1].x) / 2 - width / 2\n        : guide.points[0].x;\n    const y = xLength > yLength\n        ? guide.points[0].y\n        : (guide.points[0].y + guide.points[1].y) / 2 - fontSize / 2;\n    const transform = [\n        `scale(${reverseScale})`,\n        xLength > yLength\n            ? `translate(0, ${startMargin + vPadding})`\n            : `translate(${startMargin + hPadding}, 0)`,\n    ].join(\" \");\n    const cx = x + width / 2;\n    const cy = y + fontSize / 2;\n    const transformOrigin = xLength > yLength ? `${cx} ${y}` : `${x} ${cy}`;\n    return svg `\n    <g class=\"distance-tooltip\">\n      <rect\n        x=${x - hPadding}\n        y=${y - vPadding}\n        rx=\"2\"\n        width=${width + hPadding * 2}\n        height=${fontSize + vPadding * 2}\n        transform=${transform}\n        transform-origin=${transformOrigin}\n        stroke=\"none\"\n      />\n\n      <text\n        x=${cx}\n        y=${y + fontSize - vPadding / 2}\n        text-anchor=\"middle\"\n        transform=${transform}\n        transform-origin=${transformOrigin}\n        stroke=\"none\"\n        fill=\"white\"\n        style=\"font-size: ${fontSize}px\"\n      >\n        ${text}\n      </text>\n    </g>\n  `;\n};\nconst guidesCache = new Map();\nexport const Guides = ({ node, distanceTo, reverseScale, fontSize, }) => {\n    const combinedId = node.id + \"\\n\" + distanceTo.id;\n    let guides = guidesCache.get(combinedId);\n    if (!guides) {\n        guides = getDistanceGuides(node.absoluteBoundingBox, distanceTo.absoluteBoundingBox);\n        guidesCache.set(combinedId, guides);\n    }\n    return [\n        ...guides.map((guide) => Line({ guide, reverseScale })),\n        ...guides.map((guide) => Tooltip({ guide, reverseScale, fontSize })),\n    ];\n};\nexport const styles = css `\n  .distance-line {\n    shape-rendering: geometricPrecision;\n    fill: none;\n    opacity: 0;\n  }\n\n  .distance-tooltip {\n    opacity: 0;\n  }\n\n  .guide:hover ~ .distance-line,\n  .guide:hover ~ .distance-tooltip {\n    opacity: 1;\n  }\n`;\n","import { svg } from \"lit-element\";\nexport const CloseIcon = ({ onClick = () => { } }) => svg `\n  <svg @click=${onClick} title=\"close icon\" width=\"14\" height=\"14\" viewBox=\"0 0 20 20\" fill=\"none\">\n    <path d=\"M1 19L19 1M19 19L1 1\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n  </svg>\n`;\nexport const CopyIcon = ({ onClick = () => { } }) => svg `\n  <svg @click=${onClick} title=\"copy icon\" width=\"14\" height=\"14\" viewBox=\"0 0 30 30\" fill=\"none\">\n  <path d=\"M21 25.5C21 24.9477 20.5523 24.5 20 24.5C19.4477 24.5 19 24.9477 19 25.5H21ZM13 2H25V0H13V2ZM28 5V21H30V5H28ZM25 24H13V26H25V24ZM10 21V5H8V21H10ZM13 24C11.3431 24 10 22.6569 10 21H8C8 23.7614 10.2386 26 13 26V24ZM28 21C28 22.6569 26.6569 24 25 24V26C27.7614 26 30 23.7614 30 21H28ZM25 2C26.6569 2 28 3.34315 28 5H30C30 2.23858 27.7614 0 25 0V2ZM13 0C10.2386 0 8 2.23858 8 5H10C10 3.34315 11.3431 2 13 2V0ZM16.5 28H5V30H16.5V28ZM2 25V10H0V25H2ZM5 28C3.34315 28 2 26.6569 2 25H0C0 27.7614 2.23858 30 5 30V28ZM5 7H8V5H5V7ZM2 10C2 8.34315 3.34315 7 5 7V5C2.23858 5 0 7.23858 0 10H2ZM16.5 30C18.9853 30 21 27.9853 21 25.5H19C19 26.8807 17.8807 28 16.5 28V30Z\" fill=\"#B3B3B3\"/>\n</svg>\n`;\nexport const HorizontalPaddingIcon = () => svg `\n  <svg title=\"horizontal padding\" width=\"14\" height=\"14\" viewBox=\"0 0 29 28\" fill=\"none\">\n    <rect x=\"7\" y=\"8\" width=\"14\" height=\"14\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n    <path d=\"M27 1V28\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n    <path d=\"M1 0V28\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n  </svg>\n`;\nexport const VerticalPaddingIcon = () => svg `\n  <svg title=\"vertical padding\" width=\"14\" height=\"14\" viewBox=\"0 0 29 28\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\">\n    <rect x=\"8\" y=\"21\" width=\"14\" height=\"14\" transform=\"rotate(-90 8 21)\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n    <path d=\"M1 1L28 0.999999\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n    <path d=\"M0 27L28 27\" stroke=\"#B3B3B3\" stroke-width=\"2\"/>\n  </svg>\n`;\nexport const FigmaIcon = () => svg `\n  <svg title=\"figma logo\" width=\"11\" height=\"16\" viewBox=\"0 0 12 17\" xmlns=\"http://www.w3.org/2000/svg\">\n    <path\n      d=\"M5.5 1.5h-2c-1.105 0-2 .895-2 2 0 1.105.895 2 2 2h2v-4zm-5 2c0 1.043.533 1.963 1.341 2.5C1.033 6.537.5 7.457.5 8.5c0 1.043.533 1.963 1.341 2.5C1.033 11.537.5 12.457.5 13.5c0 1.657 1.343 3 3 3 1.657 0 3-1.343 3-3V10.736c.53.475 1.232.764 2 .764 1.657 0 3-1.343 3-3 0-1.043-.533-1.963-1.341-2.5.808-.537 1.341-1.457 1.341-2.5 0-1.657-1.343-3-3-3h-5c-1.657 0-3 1.343-3 3zm1 5c0-1.105.895-2 2-2h2v4h-2c-1.105 0-2-.895-2-2zm0 5c0-1.105.895-2 2-2h2v2c0 1.105-.895 2-2 2-1.105 0-2-.895-2-2zm7-3c-1.105 0-2-.895-2-2 0-1.105.895-2 2-2 1.105 0 2 .895 2 2 0 1.105-.895 2-2 2zm0-5h-2v-4h2c1.105 0 2 .895 2 2 0 1.105-.895 2-2 2z\"\n      fill-rule=\"evenodd\"\n      fill-opacity=\"1\"\n      fill=\"#000\"\n      stroke=\"none\"\n    ></path>\n  </svg>\n`;\n","const extractColorStyle = (color) => {\n    if (color.a === 0) {\n        return \"transparent\";\n    }\n    else if (color.a < 1) {\n        return `rgba(${rgbToIntArray(color).join(\", \")}, ${color.a.toFixed(2)})`;\n    }\n    else {\n        return rgbToHex(color);\n    }\n};\nconst extractGradientColorStyle = (color) => {\n    return new Gradient(color).cssColor;\n};\nexport class Gradient {\n    constructor(data) {\n        this.gradientHandles = {\n            start: data.gradientHandlePositions[0],\n            end: data.gradientHandlePositions[1],\n        };\n        this.colors = data.gradientStops;\n        this.colorObjects = this.createColorObjects(this.colors);\n        this.angle = this.calculateAngle(this.gradientHandles.start, this.gradientHandles.end);\n    }\n    get cssGradientArray() {\n        return this.colorObjects.map((color, index) => {\n            const position = this.floatToPercent(this.colors[index].position);\n            return color + \" \" + position;\n        });\n    }\n    get cssColor() {\n        const cssGradientArray = this.cssGradientArray;\n        cssGradientArray.unshift(this.angle + \"deg\");\n        return `linear-gradient(${cssGradientArray.join(\", \")})`;\n    }\n    createColorObjects(colors) {\n        return colors.map(({ color }) => extractColorStyle(color));\n    }\n    floatToPercent(value) {\n        return (value *= 100).toFixed(0) + \"%\";\n    }\n    calculateAngle(startHandle, endHandle) {\n        const radians = Math.atan(this.calculateGradient(startHandle, endHandle));\n        return parseInt(this.radToDeg(radians).toFixed(1));\n    }\n    calculateGradient(startHandle, endHandle) {\n        return ((endHandle.y - startHandle.y) / (endHandle.x - startHandle.x)) * -1;\n    }\n    radToDeg(radian) {\n        return (180 * radian) / Math.PI;\n    }\n}\nexport class NodeStyles {\n    constructor(node) {\n        var _a, _b, _c;\n        this.hasPadding = false;\n        this.height = `${Math.trunc(node.absoluteBoundingBox.height)}px`;\n        this.width = `${Math.trunc(node.absoluteBoundingBox.width)}px`;\n        // paddings\n        if (node.horizontalPadding || node.verticalPadding) {\n            this.hasPadding = true;\n            this.horizontalPadding = `${node.horizontalPadding}px`;\n            this.verticalPadding = `${node.verticalPadding}px`;\n        }\n        // font styles\n        if (node.style) {\n            this.fontFamily = node.style.fontFamily;\n            this.fontPostScriptName = (_a = node.style.fontPostScriptName) === null || _a === void 0 ? void 0 : _a.replace(\"-\", \" \");\n            this.fontWeight = node.style.fontWeight;\n            this.fontSize = `${Math.ceil(node.style.fontSize)}px`;\n            this.lineHeight = `${Math.trunc(node.style.lineHeightPx)}px`;\n        }\n        // border radii\n        if (node.rectangleCornerRadii) {\n            this.borderRadius =\n                node.rectangleCornerRadii.filter((radius) => radius === node.cornerRadius).length < 4\n                    ? `${node.rectangleCornerRadii.join(\"px \")}px`\n                    : `${node.cornerRadius}px`;\n        }\n        // colors, background, fill\n        if (node.backgroundColor || node.backgroundColor) {\n            const color = node.backgroundColor || ((_b = node.background) === null || _b === void 0 ? void 0 : _b[0].color);\n            this.background = extractColorStyle(color);\n        }\n        const fillColor = (_c = node.fills) === null || _c === void 0 ? void 0 : _c[0];\n        if (fillColor && fillColor.visible !== false) {\n            if (node.type === \"TEXT\") {\n                this.color = extractColorStyle(fillColor.color);\n            }\n            else if (fillColor.type.includes(\"GRADIENT\")) {\n                this.backgroundImage = extractGradientColorStyle(fillColor);\n            }\n            else if (fillColor.type === \"SOLID\") {\n                this.background = extractColorStyle(fillColor.color);\n            }\n        }\n        // borders\n        if (node.strokes && node.strokes.length > 0) {\n            this.borderColor = extractColorStyle(node.strokes[0].color);\n            this.border = `${node.strokeWeight}px solid ${this.borderColor}`;\n        }\n        // box-shadow\n        if (node.effects && node.effects.length > 0) {\n            const { offset, radius, color } = node.effects[0];\n            this.boxShadowColor = extractColorStyle(color);\n            this.boxShadow = `${(offset === null || offset === void 0 ? void 0 : offset.x) || 0}px ${(offset === null || offset === void 0 ? void 0 : offset.y) || 0}px 0 ${radius} ${this.boxShadowColor}`;\n        }\n    }\n    getStyles() {\n        return [\n            this.height && { property: \"height\", value: this.height },\n            this.width && { property: \"width\", value: this.width },\n            this.fontFamily && { property: \"font-family\", value: this.fontFamily },\n            this.fontSize && { property: \"font-size\", value: this.fontSize },\n            this.fontWeight && { property: \"font-weight\", value: this.fontWeight },\n            this.lineHeight && { property: \"line-height\", value: this.lineHeight },\n            this.borderRadius && {\n                property: \"border-radius\",\n                value: this.borderRadius,\n            },\n            this.backgroundImage && {\n                property: \"background-image\",\n                value: this.backgroundImage,\n            },\n            this.boxShadow && {\n                property: \"box-shadow\",\n                value: this.boxShadow,\n                color: this.boxShadowColor,\n            },\n            this.border && {\n                property: \"border\",\n                value: this.border,\n                color: this.borderColor,\n            },\n            this.background && {\n                property: \"background\",\n                value: this.background,\n                color: this.background,\n            },\n            this.color && { property: \"color\", value: this.color, color: this.color },\n        ].filter(Boolean);\n    }\n    getStyleSheet() {\n        return this.getStyles().map(getStyleRule).join(\"\\n\");\n    }\n}\nconst rgbToIntArray = (color) => [\n    Math.trunc(255 * color.r),\n    Math.trunc(255 * color.g),\n    Math.trunc(255 * color.b),\n];\nconst rgbToHex = (color) => {\n    const [r, g, b] = rgbToIntArray(color);\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1);\n};\nexport const getStyleRule = ({ property, value }) => `${property}: ${value};`;\n","import { css, html } from \"lit-element\";\nimport * as copy from \"copy-to-clipboard\";\nimport { HorizontalPaddingIcon, VerticalPaddingIcon, CloseIcon, CopyIcon, } from \"../Icons\";\nimport { getStyleRule, NodeStyles } from \"./utils\";\nexport const View = ({ node, onClose }) => {\n    if (!node) {\n        return null;\n    }\n    const nodeStyles = new NodeStyles(node);\n    // In order to disable canvas interactions (e.g. pan, click to\n    // deselect), we need to cancel JavaScript event propagation\n    // on the root element.\n    const stopPropagation = (ev) => ev.stopPropagation();\n    return html `\n    <div\n      class=\"inspector-view\"\n      @click=${stopPropagation}\n      @wheel=${stopPropagation}\n      @keydown=${stopPropagation}\n      @keyup=${stopPropagation}\n      @pointermove=${stopPropagation}\n    >\n      <div class=\"inspector-section selectable-content\">\n        <div class=\"title-section\">\n          <h4>${node.name}</h4>\n          ${CloseIcon({ onClick: onClose })}\n        </div>\n        <div class=\"properties-overview\">\n          <div class=\"title-section\">\n            <p class=\"inspector-property\">\n              <span>W: </span>${nodeStyles.width}\n            </p>\n            <p class=\"inspector-property\" style=\"margin-left: 16px;\">\n              <span>H: </span>${nodeStyles.height}\n            </p>\n          </div>\n          ${nodeStyles.fontPostScriptName\n        ? html `<p class=\"inspector-property\">\n                <span>Font:</span>\n                ${nodeStyles.fontPostScriptName}\n              </p>`\n        : null}\n        </div>\n      </div>\n      ${nodeStyles.hasPadding\n        ? html `<div class=\"inspector-section\">\n            <h4>Layout</h4>\n            ${nodeStyles.horizontalPadding &&\n            html `<p class=\"inspector-property\">\n              ${HorizontalPaddingIcon()} ${nodeStyles.horizontalPadding}\n            </p>`}\n            ${nodeStyles.verticalPadding &&\n            html `<p class=\"inspector-property\">\n              ${VerticalPaddingIcon()} ${nodeStyles.verticalPadding}\n            </p>`}\n          </div>`\n        : null}\n      ${node.characters\n        ? html `<div class=\"inspector-section\">\n            <div class=\"title-section\">\n              <h4>Content</h4>\n              ${CopyIcon({ onClick: () => copy(node.characters) })}\n            </div>\n            <p class=\"node-content code-section selectable-content\">\n              ${node.characters}\n            </p>\n          </div>`\n        : null}\n      ${StylesSection(nodeStyles)}\n    </div>\n  `;\n};\nexport const StylesSection = (nodeStyles) => {\n    const onClick = () => copy(nodeStyles.getStyleSheet());\n    const styles = nodeStyles.getStyles();\n    return html `<div class=\"inspector-section\">\n    <div class=\"title-section style-section\">\n      <h4>CSS</h4>\n      ${CopyIcon({ onClick })}\n    </div>\n    <div class=\"code-section selectable-content\">\n      ${styles.map(CSSProperty)}\n    </div>\n  </div>`;\n};\nconst CSSProperty = (cssProperty) => {\n    const { property, value, color } = cssProperty;\n    let coloredSquare = null;\n    switch (property) {\n        case \"background\":\n        case \"fill\":\n        case \"border\":\n        case \"box-shadow\":\n        case \"color\":\n            coloredSquare = html `<span\n        class=\"color-preview\"\n        style=\"background-color: ${color}\"\n      ></span>`;\n            break;\n        case \"background-image\":\n            coloredSquare = html `<span\n        class=\"color-preview\"\n        style=\"background-image: ${value}\"\n      ></span>`;\n            break;\n    }\n    return html `<div class=\"css-property\" @click=${() => copy(getStyleRule(cssProperty))}>\n    <span>${property}:</span>${coloredSquare}<span class=\"css-value\">${value}</span>;</span>\n  </div>`;\n};\nexport const styles = css `\n  .inspector-view {\n    height: 100%;\n    width: 300px;\n    position: absolute;\n    right: 0;\n    background: white;\n    border-left: 1px solid #ccc;\n    overflow-y: auto;\n    z-index: calc(var(--z-index) + 2);\n  }\n\n  .inspector-view h4 {\n    font-size: 16px;\n    margin: 0;\n  }\n\n  .style-section {\n    margin-bottom: 12px;\n  }\n\n  .title-section {\n    display: flex;\n    align-items: center;\n  }\n\n  .code-section {\n    padding: 8px;\n    background: #f3f3f3;\n    font-family: monospace;\n  }\n\n  .title-section svg {\n    cursor: pointer;\n    margin-left: auto;\n  }\n\n  .inspector-section {\n    padding: 16px;\n    border-bottom: 1px solid #eee;\n  }\n\n  .properties-overview {\n    font-family: monospace;\n    color: #518785;\n  }\n\n  .properties-overview p span {\n    color: #121212;\n  }\n\n  .inspector-property {\n    display: flex;\n    align-items: center;\n    margin-bottom: 0;\n  }\n\n  .inspector-property span {\n    color: #b3b3b3;\n    margin-right: 4px;\n  }\n\n  .inspector-property svg {\n    margin-right: 8px;\n  }\n\n  .css-property {\n    margin: 8px;\n    transition: background-color ease-in-out 100ms;\n  }\n\n  .css-property:hover {\n    cursor: pointer;\n    background-color: #e8e8e8;\n  }\n\n  .css-value {\n    color: #518785;\n    margin-left: 4px;\n  }\n\n  .color-preview {\n    display: inline-block;\n    width: 12px;\n    height: 12px;\n    border: 1px solid #ccc;\n    margin-left: 4px;\n    vertical-align: middle;\n  }\n\n  .selectable-content {\n    cursor: text;\n    user-select: text;\n  }\n`;\n","import { css, html, svg } from \"lit-element\";\nimport { styleMap } from \"lit-html/directives/style-map\";\nimport { round } from \"./utils\";\nexport const Outline = ({ node, selected = false, computedThickness, onClick, }) => {\n    const { x, y, width, height } = node.absoluteBoundingBox;\n    const radius = \"cornerRadius\" in node && node.cornerRadius\n        ? {\n            topLeft: node.cornerRadius,\n            topRight: node.cornerRadius,\n            bottomRight: node.cornerRadius,\n            bottomLeft: node.cornerRadius,\n        }\n        : \"rectangleCornerRadii\" in node && node.rectangleCornerRadii\n            ? {\n                topLeft: node.rectangleCornerRadii[0],\n                topRight: node.rectangleCornerRadii[1],\n                bottomRight: node.rectangleCornerRadii[2],\n                bottomLeft: node.rectangleCornerRadii[3],\n            }\n            : {\n                topLeft: 0,\n                topRight: 0,\n                bottomRight: 0,\n                bottomLeft: 0,\n            };\n    // Since SVG can't control where to draw borders (I mean you can't draw inset borders), we need to\n    // shift each drawing points by the half of the border width.\n    const shift = computedThickness / 2;\n    // https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/d\n    // [M] ... Move to\n    // [L] ... Line to\n    // [A] ... Arc to\n    // [Z] ... Close path\n    const moveTo = (x, y) => `M${x},${y}`;\n    const lineTo = (x, y) => `L${x},${y}`;\n    const arcTo = (r, x, y) => `A${r},${r} 0 0 1 ${x},${y}`;\n    const boxPath = [\n        moveTo(radius.topLeft + shift, shift),\n        lineTo(width - radius.topRight, shift),\n        arcTo(radius.topRight - shift, width - shift, radius.topRight),\n        lineTo(width - shift, height - radius.bottomRight),\n        arcTo(radius.bottomRight - shift, width - radius.bottomRight, height - shift),\n        lineTo(radius.bottomLeft, height - shift),\n        arcTo(radius.bottomLeft - shift, shift, height - radius.bottomLeft),\n        lineTo(shift, radius.topLeft),\n        arcTo(radius.topLeft - shift, radius.topLeft, shift),\n        \"Z\",\n    ].join(\" \");\n    return svg `\n    <path\n      class=\"guide\"\n      d=${boxPath}\n      shape-rendering=\"geometricPrecision\"\n      fill=\"none\"\n      transform=\"translate(${x}, ${y})\"\n      ?data-selected=${selected}\n      @click=${onClick}\n    />\n  `;\n};\nexport const Tooltip = ({ nodeSize: { x, y, width, height }, offsetX, offsetY, reverseScale, }) => {\n    const tooltipStyle = {\n        top: `${offsetY + y + height}px`,\n        left: `${offsetX + x + width / 2}px`,\n        transform: `translateX(-50%) scale(${reverseScale}) translateY(0.25em)`,\n    };\n    return html `\n    <div class=\"tooltip\" style=\"${styleMap(tooltipStyle)}\">\n      ${round(width)} x ${round(height)}\n    </div>\n  `;\n};\nexport const styles = css `\n  .guide {\n    /*\n     * SVGs cannot be pixel perfect, especially floating values.\n     * Since many platform renders them visually incorrectly (probably they\n     * are following the spec), it's safe to set overflow to visible.\n     * Cropped borders are hard to visible and ugly.\n     */\n    overflow: visible;\n\n    pointer-events: all;\n\n    opacity: 0;\n  }\n  .guide:hover {\n    opacity: 1;\n  }\n  .guide[data-selected] {\n    opacity: 1;\n    stroke: var(--guide-selected-color);\n  }\n\n  .tooltip {\n    position: absolute;\n    padding: 0.25em 0.5em;\n    font-size: var(--guide-tooltip-font-size);\n\n    color: var(--guide-selected-tooltip-fg);\n    background-color: var(--guide-selected-tooltip-bg);\n    border-radius: 2px;\n    pointer-events: none;\n    z-index: calc(var(--z-index) + 1);\n\n    transform-origin: top center;\n  }\n`;\n","const SECOND = 1000;\nconst MINUTE = 60 * SECOND;\nconst HOUR = 60 * MINUTE;\nconst DAY = 24 * HOUR;\nconst WEEK = 7 * DAY;\nconst MONTH = 30 * DAY;\nconst YEAR = 365 * DAY;\nconst intervals = [\n    { gte: YEAR, divisor: YEAR, unit: \"year\" },\n    { gte: MONTH, divisor: MONTH, unit: \"month\" },\n    { gte: WEEK, divisor: WEEK, unit: \"week\" },\n    { gte: DAY, divisor: DAY, unit: \"day\" },\n    { gte: HOUR, divisor: HOUR, unit: \"hour\" },\n    { gte: MINUTE, divisor: MINUTE, unit: \"minute\" },\n    { gte: 30 * SECOND, divisor: SECOND, unit: \"seconds\" },\n    { gte: 0, divisor: 1, text: \"just now\" },\n];\nconst getTime = (targetDate) => {\n    const date = typeof targetDate === \"object\"\n        ? targetDate\n        : new Date(targetDate);\n    return date.getTime();\n};\n/**\n * Receives two dates to compare and returns \"time ago\" based on them\n * example: 4 weeks ago\n *\n * Heavily inspired by https://stackoverflow.com/a/67338038/938822\n */\nexport const fromNow = (date, nowDate = Date.now(), rft = new Intl.RelativeTimeFormat(undefined, { numeric: \"auto\" })) => {\n    const now = getTime(nowDate);\n    const diff = now - getTime(date);\n    const diffAbs = Math.abs(diff);\n    for (const interval of intervals) {\n        if (diffAbs >= interval.gte) {\n            const x = Math.round(Math.abs(diff) / interval.divisor);\n            const isInFuture = diff < 0;\n            const intervalUnit = interval.unit;\n            return intervalUnit\n                ? rft.format(isInFuture ? x : -x, intervalUnit)\n                : interval.text;\n        }\n    }\n};\n","import { css, html } from \"lit-element\";\nimport { FigmaIcon } from \"../Icons\";\nimport { fromNow } from \"./utils\";\nexport const styles = css `\n  .figma-footer {\n    flex: 0;\n    z-index: calc(var(--z-index) + 1);\n    border-top: 1px solid #ccc;\n    min-height: 48px;\n    padding: 0 16px;\n    text-decoration: none;\n    display: flex;\n    flex-direction: row;\n    justify-content: start;\n    align-items: center;\n    background-color: #fff;\n    overflow-x: auto;\n    cursor: pointer;\n    font-size: 12px;\n    color: rgba(0, 0, 0, 0.8);\n  }\n\n  .figma-footer--icon {\n    margin-right: 12px;\n  }\n\n  .figma-footer--title {\n    font-weight: 600;\n    margin-right: 4px;\n\n    white-space: nowrap;\n    overflow: hidden;\n    text-overflow: ellipsis;\n  }\n\n  .figma-footer--timestamp {\n    white-space: nowrap;\n    overflow: hidden;\n  }\n`;\nexport const Footer = (metadata) => {\n    // Do not render in case there is no metadata or a link is not passed\n    if (!metadata ||\n        !metadata.link ||\n        metadata.link === undefined ||\n        metadata.link === \"undefined\") {\n        return null;\n    }\n    const { link, timestamp, fileName } = metadata;\n    return html `<a\n    class=\"figma-footer\"\n    target=\"_blank\"\n    rel=\"noopener\"\n    title=\"Open in Figma\"\n    href=\"${link}\"\n  >\n    <span class=\"figma-footer--icon\"> ${FigmaIcon()} </span>\n    <span class=\"figma-footer--title\"> ${fileName} </span>\n    <span\n      title=\"Last time edited: ${new Date(timestamp).toUTCString()}\"\n      class=\"figma-footer--timestamp\"\n    >\n      Edited ${fromNow(timestamp)}\n    </span>\n  </a>`;\n};\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, privateMap, value) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to set private field on non-instance\");\n    }\n    privateMap.set(receiver, value);\n    return value;\n};\nimport { css, html, svg, property, } from \"lit-element\";\nimport { styleMap } from \"lit-html/directives/style-map\";\nimport { extendStyles } from \"./utils\";\nimport { NodeSelectableMixin } from \"./NodeSelectableMixin\";\nimport { PositionedMixin } from \"./PositionedMixin\";\nimport * as DistanceGuide from \"./DistanceGuide\";\nimport * as InspectorView from \"./InspectorView/InspectorView\";\nimport * as ErrorMessage from \"./ErrorMessage\";\nimport * as Node from \"./Node\";\nimport * as FigmaFooter from \"./Footer/Footer\";\nexport const ViewerMixin = (superClass) => {\n    var _canvasSize, _effectMargins, _flattenedNodes, _handleNodeClick, _getNodeById;\n    class Viewer extends NodeSelectableMixin(PositionedMixin(superClass)) {\n        constructor(...args) {\n            super(...args);\n            this.zoomMargin = 50;\n            this.link = \"\";\n            // Cached values\n            _canvasSize.set(this, void 0);\n            _effectMargins.set(this, void 0);\n            _flattenedNodes.set(this, void 0);\n            _handleNodeClick.set(this, (node) => (ev) => {\n                ev.preventDefault();\n                ev.stopPropagation();\n                this.selectedNode = node;\n            });\n            _getNodeById.set(this, (id) => {\n                var _a, _b;\n                return (_b = (_a = __classPrivateFieldGet(this, _flattenedNodes)) === null || _a === void 0 ? void 0 : _a.find((n) => n.id === id)) !== null && _b !== void 0 ? _b : null;\n            });\n        }\n        static get styles() {\n            // @ts-ignore\n            const styles = super.styles;\n            return extendStyles(styles, [\n                css `\n          :host {\n            --default-error-bg: #fff;\n            --default-error-fg: #333;\n\n            --bg: var(--figspec-viewer-bg, #e5e5e5);\n            --z-index: var(--figspec-viewer-z-index, 0);\n            --error-bg: var(--figspec-viewer-error-bg, var(--default-error-bg));\n            --error-fg: var(--figspec-viewer-error-fg, var(--default-error-fg));\n            --error-color: var(--figspec-viewer-error-color, tomato);\n\n            --guide-thickness: var(--figspec-viewer-guide-thickness, 1.5px);\n            --guide-color: var(--figspec-viewer-guide-color, tomato);\n            --guide-selected-color: var(\n              --figspec-viewer-guide-selected-color,\n              dodgerblue\n            );\n            --guide-tooltip-fg: var(--figspec-viewer-guide-tooltip-fg, white);\n            --guide-selected-tooltip-fg: var(\n              --figspec-viewer-guide-selected-tooltip-fg,\n              white\n            );\n            --guide-tooltip-bg: var(\n              --figspec-viewer-guide-tooltip-bg,\n              var(--guide-color)\n            );\n            --guide-selected-tooltip-bg: var(\n              --figspec-viewer-guide-selected-tooltip-bg,\n              var(--guide-selected-color)\n            );\n            --guide-tooltip-font-size: var(\n              --figspec-viewer-guide-tooltip-font-size,\n              12px\n            );\n\n            position: relative;\n            display: block;\n\n            background-color: var(--bg);\n            user-select: none;\n            overflow: hidden;\n            z-index: var(--z-index);\n          }\n\n          @media (prefers-color-scheme: dark) {\n            :host {\n              --default-error-bg: #222;\n              --default-error-fg: #fff;\n            }\n          }\n\n          .spec-canvas-wrapper {\n            position: absolute;\n            top: 0;\n            left: 0;\n            width: 100%;\n            height: 100%;\n            display: flex;\n            flex-direction: column-reverse;\n          }\n\n          .canvas {\n            position: absolute;\n            top: 50%;\n            left: 50%;\n            flex: 1;\n          }\n\n          .rendered-image {\n            position: absolute;\n            top: 0;\n            left: 0;\n          }\n\n          .guides {\n            position: absolute;\n\n            overflow: visible;\n            stroke: var(--guide-color);\n            fill: var(--guide-color);\n            pointer-events: none;\n            z-index: calc(var(--z-index) + 2);\n          }\n        `,\n                Node.styles,\n                ErrorMessage.styles,\n                DistanceGuide.styles,\n                InspectorView.styles,\n                FigmaFooter.styles,\n            ]);\n        }\n        get __images() {\n            return {};\n        }\n        deselectNode() {\n            this.selectedNode = null;\n        }\n        get error() {\n            if (!__classPrivateFieldGet(this, _canvasSize) || !__classPrivateFieldGet(this, _flattenedNodes)) {\n                return ErrorMessage.ErrorMessage({\n                    title: \"Error\",\n                    children: \"Please call `__updateTree/1` method with a valid parameter.\",\n                });\n            }\n            return null;\n        }\n        render() {\n            if (this.error) {\n                if (this.error instanceof Error) {\n                    return ErrorMessage.ErrorMessage({\n                        title: this.error.name || \"Error\",\n                        children: this.error.message,\n                    });\n                }\n                if (typeof this.error === \"string\") {\n                    return ErrorMessage.ErrorMessage({\n                        title: \"Error\",\n                        children: this.error,\n                    });\n                }\n                return this.error;\n            }\n            const canvasSize = __classPrivateFieldGet(this, _canvasSize);\n            const reverseScale = 1 / this.scale;\n            const guideThickness = `calc(var(--guide-thickness) * ${reverseScale})`;\n            const computedGuideThickness = parseFloat(getComputedStyle(this).getPropertyValue(\"--guide-thickness\"));\n            const computedGuideTooltipFontSize = parseFloat(getComputedStyle(this).getPropertyValue(\"--guide-tooltip-font-size\"));\n            return html `\n        <div class=\"spec-canvas-wrapper\" @click=${this.deselectNode}>\n          <div\n            class=\"canvas\"\n            style=\"\n          width: ${canvasSize.width}px;\n          height: ${canvasSize.height}px;\n\n          transform: translate(-50%, -50%) ${this.canvasTransform.join(\" \")}\n        \"\n          >\n            ${Object.entries(this.__images).map(([nodeId, uri]) => {\n                var _a;\n                const node = __classPrivateFieldGet(this, _getNodeById).call(this, nodeId);\n                if (!node ||\n                    !(\"absoluteBoundingBox\" in node) ||\n                    !((_a = __classPrivateFieldGet(this, _effectMargins)) === null || _a === void 0 ? void 0 : _a[node.id])) {\n                    return null;\n                }\n                const margin = __classPrivateFieldGet(this, _effectMargins)[node.id];\n                return html `\n                <img class=\"rendered-image\" src=\"${uri}\"\n                style=${styleMap({\n                    top: `${node.absoluteBoundingBox.y - canvasSize.y}px`,\n                    left: `${node.absoluteBoundingBox.x - canvasSize.x}px`,\n                    marginTop: `${-margin.top}px`,\n                    marginLeft: `${-margin.left}px`,\n                    width: node.absoluteBoundingBox.width +\n                        margin.left +\n                        margin.right +\n                        \"px\",\n                    height: node.absoluteBoundingBox.height +\n                        margin.top +\n                        margin.bottom +\n                        \"px\",\n                })}\"\n                \" />\n              `;\n            })}\n            ${this.selectedNode &&\n                Node.Tooltip({\n                    nodeSize: this.selectedNode.absoluteBoundingBox,\n                    offsetX: -canvasSize.x,\n                    offsetY: -canvasSize.y,\n                    reverseScale,\n                })}\n            ${svg `\n            <svg\n              class=\"guides\"\n              viewBox=\"0 0 5 5\"\n              width=\"5\"\n              height=\"5\"\n              style=${styleMap({\n                left: `${-canvasSize.x}px`,\n                top: `${-canvasSize.y}px`,\n                strokeWidth: guideThickness,\n            })}\n            >\n              ${this.selectedNode &&\n                Node.Outline({\n                    node: this.selectedNode,\n                    selected: true,\n                    computedThickness: computedGuideThickness * reverseScale,\n                })}\n\n              ${__classPrivateFieldGet(this, _flattenedNodes).map((node) => {\n                var _a;\n                if (node.id === ((_a = this.selectedNode) === null || _a === void 0 ? void 0 : _a.id)) {\n                    return null;\n                }\n                return svg `\n                  <g>\n                    ${Node.Outline({\n                    node,\n                    computedThickness: computedGuideThickness * reverseScale,\n                    onClick: __classPrivateFieldGet(this, _handleNodeClick).call(this, node),\n                })}\n                    ${this.selectedNode &&\n                    DistanceGuide.Guides({\n                        node,\n                        distanceTo: this.selectedNode,\n                        reverseScale,\n                        fontSize: computedGuideTooltipFontSize,\n                    })}\n                  </g>\n                `;\n            })}\n            </svg>\n          `}\n          </div>\n          ${InspectorView.View({\n                node: this.selectedNode,\n                onClose: this.deselectNode,\n            })}\n          ${FigmaFooter.Footer(this.getMetadata())}\n        </div>\n      `;\n        }\n        // implemented in FileViewer/FrameViewer\n        getMetadata() {\n            return undefined;\n        }\n        connectedCallback() {\n            super.connectedCallback();\n            this.resetZoom();\n        }\n        updated(changedProperties) {\n            super.updated(changedProperties);\n        }\n        __updateTree(node) {\n            if (!(node.type === \"CANVAS\" ||\n                node.type === \"FRAME\" ||\n                node.type === \"COMPONENT\" ||\n                //@ts-ignore NOTE: figma-js does not implement COMPONENT_SET type (yet?)\n                node.type === \"COMPONENT_SET\")) {\n                throw new Error(\"Cannot update node tree: Top level node MUST be one of CANVAS, FRAME, COMPONENT, or COMPONENT_SET\");\n            }\n            __classPrivateFieldSet(this, _canvasSize, node.type === \"CANVAS\" ? getCanvasSize(node) : node.absoluteBoundingBox);\n            __classPrivateFieldSet(this, _flattenedNodes, flattenNode(node));\n            // Since above properties aren't \"attribute\", their changes does not\n            // trigger an update. We need to manually request an update.\n            this.requestUpdate();\n        }\n        __updateEffectMargins() {\n            if (!this.__images) {\n                return;\n            }\n            const containers = Object.keys(this.__images)\n                .map(__classPrivateFieldGet(this, _getNodeById))\n                .filter((n) => !!n);\n            __classPrivateFieldSet(this, _effectMargins, containers.reduce((margin, node) => {\n                if (!(\"absoluteBoundingBox\" in node)) {\n                    return margin;\n                }\n                return Object.assign(Object.assign({}, margin), { [node.id]: getEffectMargin(node, flattenNode(node)) });\n            }, {}));\n            this.requestUpdate();\n        }\n        resetZoom() {\n            if (__classPrivateFieldGet(this, _canvasSize)) {\n                // Set initial zoom level based on element size\n                const { width, height } = __classPrivateFieldGet(this, _canvasSize);\n                const { width: elementWidth, height: elementHeight, } = this.getBoundingClientRect();\n                const wDiff = elementWidth / (width + this.zoomMargin * 2);\n                const hDiff = elementHeight / (height + this.zoomMargin * 2);\n                this.scale = Math.min(wDiff, hDiff, 1);\n            }\n        }\n    }\n    _canvasSize = new WeakMap(), _effectMargins = new WeakMap(), _flattenedNodes = new WeakMap(), _handleNodeClick = new WeakMap(), _getNodeById = new WeakMap();\n    __decorate([\n        property({\n            type: Number,\n            attribute: \"zoom-margin\",\n        })\n    ], Viewer.prototype, \"zoomMargin\", void 0);\n    __decorate([\n        property({\n            type: String,\n            attribute: \"link\",\n        })\n    ], Viewer.prototype, \"link\", void 0);\n    return Viewer;\n};\nfunction getCanvasSize(node) {\n    const left = [];\n    const right = [];\n    const top = [];\n    const bottom = [];\n    for (const child of node.children) {\n        if (child.type !== \"FRAME\" && child.type !== \"COMPONENT\") {\n            continue;\n        }\n        const { x, y, width, height } = child.absoluteBoundingBox;\n        left.push(x);\n        right.push(x + width);\n        top.push(y);\n        bottom.push(y + height);\n    }\n    const minX = Math.min(...left);\n    const minY = Math.min(...top);\n    return {\n        x: minX,\n        y: minY,\n        width: Math.abs(Math.max(...right) - minX),\n        height: Math.abs(Math.min(...bottom) - minY),\n    };\n}\nfunction getEffectMargin(container, nodes) {\n    const points = nodes.map((node) => {\n        if (!(\"effects\" in node)) {\n            return {\n                top: node.absoluteBoundingBox.y,\n                right: node.absoluteBoundingBox.x + node.absoluteBoundingBox.width,\n                bottom: node.absoluteBoundingBox.y + node.absoluteBoundingBox.height,\n                left: node.absoluteBoundingBox.x,\n            };\n        }\n        const blurRadiuses = node.effects\n            .filter((effect) => effect.visible && effect.type === \"LAYER_BLUR\")\n            .map((effect) => effect.radius);\n        const shadowMargins = node.effects\n            .filter((effect) => effect.visible && effect.type === \"DROP_SHADOW\" && !!effect.offset)\n            .map((effect) => {\n            return {\n                left: effect.radius - effect.offset.x,\n                top: effect.radius - effect.offset.y,\n                right: effect.radius + effect.offset.x,\n                bottom: effect.radius + effect.offset.y,\n            };\n        });\n        const margin = {\n            top: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.top)),\n            right: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.right)),\n            bottom: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.bottom)),\n            left: Math.max(0, ...blurRadiuses, ...shadowMargins.map((margin) => margin.left)),\n        };\n        return {\n            top: node.absoluteBoundingBox.y - margin.top,\n            right: node.absoluteBoundingBox.x +\n                node.absoluteBoundingBox.width +\n                margin.right,\n            bottom: node.absoluteBoundingBox.y +\n                node.absoluteBoundingBox.height +\n                margin.bottom,\n            left: node.absoluteBoundingBox.x - margin.left,\n        };\n    });\n    const bounds = {\n        top: Math.min(...points.map((p) => p.top)),\n        right: Math.max(...points.map((p) => p.right)),\n        bottom: Math.max(...points.map((p) => p.bottom)),\n        left: Math.min(...points.map((p) => p.left)),\n    };\n    return {\n        top: container.absoluteBoundingBox.y - bounds.top,\n        right: bounds.right -\n            container.absoluteBoundingBox.x -\n            container.absoluteBoundingBox.width,\n        bottom: bounds.bottom -\n            container.absoluteBoundingBox.y -\n            container.absoluteBoundingBox.height,\n        left: container.absoluteBoundingBox.x - bounds.left,\n    };\n}\nfunction flattenNode(node, depth = 0) {\n    if (!(\"absoluteBoundingBox\" in node)) {\n        return node.children.map((child) => flattenNode(child, depth + 1)).flat();\n    }\n    if (!(\"children\" in node) || node.children.length === 0) {\n        return [Object.assign(Object.assign({}, node), { depth })];\n    }\n    return [\n        Object.assign(Object.assign({}, node), { depth }),\n        ...node.children.map((child) => flattenNode(child, depth + 1)).flat(),\n    ];\n}\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { LitElement, html, property } from \"lit-element\";\nimport * as ErrorMessage from \"./ErrorMessage\";\nimport { ViewerMixin } from \"./ViewerMixin\";\n// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)\n/**\n * A Figma spec viewer. Displays a rendered image alongside sizing guides.\n * @element figspec-frame-viewer\n *\n * @property {number} [panX=0]\n * Current pan offset in px for X axis.\n * This is a \"before the scale\" value.\n *\n * @property {number} [panY=0]\n * Current pan offset in px for Y axis.\n * This is a \"before the scale\" value.\n *\n * @property {number} [scale=1]\n * Current zoom level, where 1.0 = 100%.\n *\n * @property {number} [zoomSpeed=500]\n * How fast zooming when do ctrl+scroll / pinch gestures.\n * Available values: 1 ~ 1000\n * @attr [zoom-speed=500] See docs for `zoomSpeed` property.\n *\n * @property {number} [panSpeed=500]\n * How fast panning when scroll vertically or horizontally.\n * This does not affect to dragging with middle button pressed.\n * Available values: 1 ~ 1000.\n * @attr [pan-speed=500] See docs for `panSpeed` property.\n *\n * @property {Figma.Node | null} [selectedNode=null]\n * Current selected node.\n *\n * @property {string} [link=null]\n * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.\n *\n * @property {number} [zoomMargin=50]\n * The minimum margin for the preview canvas in px. Will be used when the preview\n * setting a default zooming scale for the canvas.\n * @attr [zoom-margin=50] See docs for `zoomMargin` property.\n *\n * @fires scalechange When a user zoom-in or zoom-out the preview.\n * @fires positionchange When a user panned the preview.\n * @fires nodeselect When a user selected / unselected a node.\n */\nexport class FigspecFrameViewer extends ViewerMixin(LitElement) {\n    constructor() {\n        super(...arguments);\n        /**\n         * A response of \"GET file nodes\" API.\n         * https://www.figma.com/developers/api#get-file-nodes-endpoint\n         */\n        this.nodes = null;\n        /**\n         * An image rendered by \"GET image\" API.\n         * https://www.figma.com/developers/api#get-images-endpoint\n         */\n        this.renderedImage = null;\n    }\n    /** @private */\n    get isMovable() {\n        return !!(this.nodes && this.renderedImage && this.documentNode);\n    }\n    /**\n     * Readonly. Document node (= root drawable node).\n     * @readonly\n     */\n    get documentNode() {\n        if (!this.nodes) {\n            return null;\n        }\n        const documentNode = Object.values(this.nodes.nodes)[0];\n        if (!documentNode || !(\"absoluteBoundingBox\" in documentNode.document)) {\n            return null;\n        }\n        return documentNode.document;\n    }\n    /** @private */\n    get __images() {\n        if (!this.documentNode || !this.renderedImage) {\n            return {};\n        }\n        return {\n            [this.documentNode.id]: this.renderedImage,\n        };\n    }\n    /** @private */\n    get error() {\n        if (!this.nodes || !this.renderedImage) {\n            return ErrorMessage.ErrorMessage({\n                title: \"Parameter error\",\n                children: html `<span>\n          Both <code>nodes</code> and <code>rendered-image</code> are required.\n        </span>`,\n            });\n        }\n        if (!this.documentNode) {\n            return ErrorMessage.ErrorMessage({\n                title: \"Parameter Error\",\n                children: html `\n          <span> Document node is empty or does not have size. </span>\n        `,\n            });\n        }\n        if (super.error) {\n            return super.error;\n        }\n    }\n    getMetadata() {\n        return {\n            fileName: this.nodes.name,\n            timestamp: this.nodes.lastModified,\n            link: this.link,\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.documentNode) {\n            this.__updateTree(this.documentNode);\n            this.__updateEffectMargins();\n            this.resetZoom();\n        }\n    }\n    updated(changedProperties) {\n        super.updated(changedProperties);\n        if (changedProperties.has(\"nodes\")) {\n            if (!this.documentNode)\n                return;\n            this.__updateTree(this.documentNode);\n            this.resetZoom();\n        }\n        if (changedProperties.has(\"renderedImage\")) {\n            this.__updateEffectMargins();\n        }\n    }\n}\n__decorate([\n    property({\n        type: Object,\n    })\n], FigspecFrameViewer.prototype, \"nodes\", void 0);\n__decorate([\n    property({\n        type: String,\n        attribute: \"rendered-image\",\n    })\n], FigspecFrameViewer.prototype, \"renderedImage\", void 0);\n","var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, privateMap) {\n    if (!privateMap.has(receiver)) {\n        throw new TypeError(\"attempted to get private field on non-instance\");\n    }\n    return privateMap.get(receiver);\n};\nvar _selectFirstPage, _handlePageChange;\nimport { LitElement, css, html, property } from \"lit-element\";\nimport * as ErrorMessage from \"./ErrorMessage\";\nimport { ViewerMixin } from \"./ViewerMixin\";\nimport { extendStyles } from \"./utils\";\n// TODO: Move docs for props in mixins (waiting for support at web-component-analyzer)\n/**\n * A Figma spec viewer. Displays a rendered image alongside sizing guides.\n * @element figspec-file-viewer\n *\n * @property {number} [panX=0]\n * Current pan offset in px for X axis.\n * This is a \"before the scale\" value.\n *\n * @property {number} [panY=0]\n * Current pan offset in px for Y axis.\n * This is a \"before the scale\" value.\n *\n * @property {number} [scale=1]\n * Current zoom level, where 1.0 = 100%.\n *\n * @property {number} [zoomSpeed=500]\n * How fast zooming when do ctrl+scroll / pinch gestures.\n * Available values: 1 ~ 1000\n * @attr [zoom-speed=500] See docs for `zoomSpeed` property.\n *\n * @property {number} [panSpeed=500]\n * How fast panning when scroll vertically or horizontally.\n * This does not affect to dragging with middle button pressed.\n * Available values: 1 ~ 1000.\n * @attr [pan-speed=500] See docs for `panSpeed` property.\n *\n * @property {Figma.Node | null} [selectedNode=null]\n * Current selected node.\n *\n * @property {string} [link=null]\n * Figma link for the given project/node. If passed, figspec will present a footer with metadata and a link to figma.\n *\n * @property {number} [zoomMargin=50]\n * The minimum margin for the preview canvas in px. Will be used when the preview\n * setting a default zooming scale for the canvas.\n * @attr [zoom-margin=50] See docs for `zoomMargin` property.\n *\n * @fires scalechange When a user zoom-in or zoom-out the preview.\n * @fires positionchange When a user panned the preview.\n * @fires nodeselect When a user selected / unselected a node.\n */\nexport class FigspecFileViewer extends ViewerMixin(LitElement) {\n    constructor() {\n        super(...arguments);\n        /**\n         * A response of \"GET file nodes\" API.\n         * https://www.figma.com/developers/api#get-file-nodes-endpoint\n         */\n        this.documentNode = null;\n        /**\n         * A record of rendered images, where key is an ID of the node,\n         * value is an URI of the image.\n         * https://www.figma.com/developers/api#get-images-endpoint\n         */\n        this.renderedImages = null;\n        /**\n         * Current selected page (node whose type is \"CANVAS\").\n         */\n        this.selectedPage = null;\n        _selectFirstPage.set(this, () => {\n            var _a;\n            if (!this.documentNode) {\n                this.selectedPage = null;\n                return;\n            }\n            this.selectedPage = (_a = this.documentNode.document.children.filter((c) => c.type === \"CANVAS\")[0]) !== null && _a !== void 0 ? _a : null;\n        });\n        _handlePageChange.set(this, (ev) => {\n            var _a, _b;\n            const target = ev.currentTarget;\n            this.selectedPage = (_b = (_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.find((c) => c.id === target.value)) !== null && _b !== void 0 ? _b : null;\n            if (this.selectedPage) {\n                this.__updateTree(this.selectedPage);\n                this.resetZoom();\n                this.__updateEffectMargins();\n                this.panX = 0;\n                this.panY = 0;\n            }\n        });\n    }\n    /** @private */\n    get isMovable() {\n        return !!(this.renderedImages && this.documentNode);\n    }\n    /** @private */\n    get __images() {\n        return this.renderedImages || {};\n    }\n    /** @private */\n    get error() {\n        if (!this.documentNode || !this.renderedImages) {\n            return ErrorMessage.ErrorMessage({\n                title: \"Parameter error\",\n                children: html `<span>\n          Both <code>document-node</code> and <code>rendered-images</code> are\n          required.\n        </span>`,\n            });\n        }\n        if (super.error) {\n            return super.error;\n        }\n    }\n    static get styles() {\n        return extendStyles(super.styles, [\n            css `\n        :host {\n          --figspec-control-bg-default: #fcfcfc;\n          --figspec-control-fg-default: #333;\n\n          --control-bg: var(\n            --figspec-control-bg,\n            var(--figspec-control-bg-default)\n          );\n          --control-fg: var(\n            --figspec-control-bg,\n            var(--figspec-control-fg-default)\n          );\n          --control-shadow: var(\n            --figspec-control-shadow,\n            0 2px 4px rgba(0, 0, 0, 0.3)\n          );\n          --padding: var(--figspec-control-padding, 8px 16px);\n\n          display: flex;\n          flex-direction: column;\n        }\n\n        @media (prefers-color-scheme: dark) {\n          :host {\n            --figspec-control-bg-default: #222;\n            --figspec-control-fg-default: #fff;\n          }\n        }\n\n        .controls {\n          flex-shrink: 0;\n          padding: var(--padding);\n\n          background-color: var(--control-bg);\n          box-shadow: var(--control-shadow);\n          color: var(--control-fg);\n          z-index: 1;\n        }\n\n        .view {\n          position: relative;\n          flex-grow: 1;\n          flex-shrink: 1;\n        }\n      `,\n        ]);\n    }\n    render() {\n        var _a;\n        return html `\n      <div class=\"controls\">\n        <select @change=${__classPrivateFieldGet(this, _handlePageChange)}>\n          ${(_a = this.documentNode) === null || _a === void 0 ? void 0 : _a.document.children.map((c) => html `<option value=${c.id}>${c.name}</option>`)}\n        </select>\n      </div>\n\n      <div class=\"view\">${super.render()}</div>\n    `;\n    }\n    getMetadata() {\n        return {\n            fileName: this.documentNode.name,\n            timestamp: this.documentNode.lastModified,\n            link: this.link,\n        };\n    }\n    connectedCallback() {\n        super.connectedCallback();\n        if (this.documentNode) {\n            __classPrivateFieldGet(this, _selectFirstPage).call(this);\n            if (this.selectedPage) {\n                this.__updateTree(this.selectedPage);\n                this.resetZoom();\n            }\n        }\n    }\n    updated(changedProperties) {\n        super.updated(changedProperties);\n        if (changedProperties.has(\"documentNode\")) {\n            __classPrivateFieldGet(this, _selectFirstPage).call(this);\n            if (this.selectedPage) {\n                this.__updateTree(this.selectedPage);\n                this.resetZoom();\n            }\n        }\n        if (changedProperties.has(\"renderedImages\")) {\n            this.__updateEffectMargins();\n        }\n    }\n}\n_selectFirstPage = new WeakMap(), _handlePageChange = new WeakMap();\n__decorate([\n    property({\n        type: Object,\n        attribute: \"document-node\",\n    })\n], FigspecFileViewer.prototype, \"documentNode\", void 0);\n__decorate([\n    property({\n        type: Object,\n        attribute: \"rendered-images\",\n    })\n], FigspecFileViewer.prototype, \"renderedImages\", void 0);\n"],"names":[],"sourceRoot":""}